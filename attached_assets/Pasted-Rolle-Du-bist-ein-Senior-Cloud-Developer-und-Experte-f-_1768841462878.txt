Rolle: Du bist ein Senior Cloud Developer und Experte für Microsoft Graph API Integrationen.

Kontext: Wir stellen unser SaaS-DMS auf einen zentralen E-Mail-Import um ("Buchhaltungsbutler-Modell").

Protokoll: Wir nutzen ausschließlich die Microsoft Graph API (via O365 Python Library oder msal), um auf ein zentrales Postfach (ingest@dms.cloud) zuzugreifen. Kein IMAP/SMTP!

Auth: Authentifizierung erfolgt als "Service Principal" (Client Credentials Flow) im Hintergrund, ohne User-Interaktion.

Security: E-Mails dürfen niemals im Postfach verbleiben ("Hot Potato Principle").

Aufgabe: Refactore dms/models.py, dms/tasks.py und dms_project/settings.py für die neue Ingest-Architektur.

Schritt 1: Datenbank (dms/models.py)

Lösche das Model EmailConfig. Wir verwalten keine individuellen Zugänge mehr.

Erweitere das Model Tenant:

Füge ingest_token hinzu (z.B. models.CharField(max_length=12, unique=True, db_index=True)).

Generiere automatisch ein Token beim Erstellen (z.B. secrets.token_hex(6)), wenn noch keines existiert.

Das Token dient zur Identifikation in der E-Mail-Adresse (z.B. upload.<token>@dms.cloud).

Schritt 2: Settings (dms_project/settings.py) Füge die notwendigen Konfigurationen für den zentralen Azure-Bot hinzu:

Python

AZURE_INGEST_CLIENT_ID = os.environ.get('AZURE_INGEST_CLIENT_ID')
AZURE_INGEST_CLIENT_SECRET = os.environ.get('AZURE_INGEST_CLIENT_SECRET')
AZURE_INGEST_TENANT_ID = os.environ.get('AZURE_INGEST_TENANT_ID')
AZURE_INGEST_MAILBOX = os.environ.get('AZURE_INGEST_MAILBOX') # z.B. ingest@dms.cloud
Schritt 3: Ingest-Task (dms/tasks.py) Schreibe poll_email_inbox komplett neu zu poll_central_inbox_graph:

Connect: Nutze O365.Account mit credentials=(client_id, client_secret) und auth_flow_type='credentials' (Wichtig für Daemon-Apps ohne User).

Fetch: Lade ungelesene Nachrichten aus der AZURE_INGEST_MAILBOX.

Routing-Logik:

Analysiere die to_recipients (und cc_recipients) der E-Mail.

Suche nach dem Pattern upload\.(?P<token>[a-f0-9-]+)@.* (oder ähnlich).

Wichtig: E-Mails können an mehrere Adressen gehen. Prüfe alle Empfänger, bis ein gültiges Tenant-Token gefunden wird.

Lade den Tenant anhand des Tokens.

Verarbeitung (Secure Processing):

Nutze with tenant_context(tenant): (aus vorherigem Task), um den Kontext zu setzen.

Rufe die bestehende process_email_message(message, tenant) auf (Signatur anpassen: config Argument entfernen, tenant hinzufügen).

Clean Up (Graph API):

Success: Lösche die E-Mail sofort via API (message.delete()). Das ist sicherer als sie nur als gelesen zu markieren.

Error (Tenant nicht gefunden / Parsing Fehler): Verschiebe die E-Mail in einen Ordner "Quarantine" (message.move(folder_id_or_name='Quarantine')), damit die Inbox leer bleibt.

Hinweis: Stelle sicher, dass keine EmailConfig Referenzen mehr im Code verbleiben und dass die Migration sauber durchläuft.